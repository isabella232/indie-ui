<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>IndieUI: Events 1.0</title>
		<link href="./css/screen.css" rel="stylesheet" type="text/css">
		<script type="text/javascript" src="./loc/en/strings.js" class="remove"></script>
		<script type="text/javascript" src="./js/utils.js" class="remove"></script>
		<script type="text/javascript" src="./js/respec-transformers.js" class="remove"></script>
		
		<!-- 
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
		<script class="remove">
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "indie-ui-events",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          subtitle   :  "Events for User Interface Independence",

          // if you wish the publication date to be other than today, set this
          //publishDate:  "2013-01-22",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2013",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "2013-01-22",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "https://dvcs.w3.org/hg/IndieUI/raw-file/default/src/indie-ui-events.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          /*
          extraCSS:             [
            "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
            "./css/screen.css"
          ],
          */

          // editors, add as many as you like
          // only "name" is required, also can have url, company, companyURL in comma separated list
          editors:  [
              { name: "James Craig", company: "Apple Inc.", companyURL: "http://www.apple.com/" },
              { name: "Michael Cooper", company: "W3C", companyURL: "http://www.w3.org/" },
          ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          //authors:  [
          //  { name: "James Craig", company: "Apple Inc.", companyURL: "http://www.apple.com/" },
          //],
          
          // name of the WG
          wg:           "Independent User Interface (Indie UI) Working Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/WAI/IndieUI/",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-indie-ui-comments",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/54953/status",
      };
    </script>
		
		
	</head>
	<body>

		<section id="abstract">
			<p>IndieUI: Events 1.0 is an abstraction between physical, device-specific user interaction events and inferred user intent such as scrolling or changing values. This provides an intermediate layer between device- and modality-specific user interaction events, and the basic user interface functionality used by web applications. IndieUI: Events focuses on granular user interface interactions such as scrolling the view, canceling an action, changing the value of a user input widget, selecting a range, placing focus on an object, etc. Implementing platforms will combine modality-specific user input, user idiosyncratic heuristics to determine the specific corresponding Indie UI event, and send that to the web application in addition to the modality-specific input such as mouse or keyboard events, should applications wish to process it.</p>
			<p>See the <a href="#intro">introduction</a> for background and usage examples.</p>
		</section>

		<section id="sotd">
		</section>
		
		<!-- :::::::::::::::::::: INTRO :::::::::::::::::::: -->
		<section id="intro" class="informative">
			<h2>Introduction</h2>
			
			<section id="intro-background">
				<h3>Background</h3>
				<p>Scripting usable interfaces can be difficult, especially when one considers that user interface design patterns differ across software platforms, hardware, and locales, and that those interactions can be further customized based on personal preference. Individuals are accustomed to the way the interface works on their own system, and their preferred interface frequently differs from that of the web application author's preferred interface.</p>
				<p>For example, web application authors, wishing to intercept a user's intent to 'zoom in' on a custom image viewer or map view, need to "listen" for all of the following events:</p>
				<ul>
					<li><kbd>Control+PLUS</kbd> on Windows and Linux.</li>
					<li><kbd>Command+PLUS</kbd> on Mac OS X.</li>
					<li>Scroll events initiated by a trackpad or mouse scroll wheel.</li>
					<li>Multiple touch or pointer events on some devices.</li>
					<li>Additional gestures or speech commands on implementations that may not currently be detectable.</li>
				</ul>
				<p>In addition to the general user interface challenges, custom interfaces often don't take into account users who access web content via assistive technologies that use alternate forms of input such as screen readers, switch interfaces, or speech-based command and control interfaces.</p>
				<p>For example, a web page author may script a custom interface to look like a slider (e.g. one styled to look like an <abbr title="Hypertext Markup Language">HTML</abbr> 'range' input) and behave like a slider when using standard mouse-based input, but there is no standard way for the value of the slider to be controlled programmatically, so the control may not be usable without a mouse or other pointer-based input.</p>
				<p>It would be simpler to listen for a normalized request to "zoom in" on the current view, whereby the web application could determine the new scale factor and update its custom view accordingly. Whether through continuous physical events like a scroll wheel or discrete physical events like the keyboard shortcuts, a user could indicate his intent to "zoom in" and the web application author would only need to listen for a single type of event: <code>zoomrequest</code>.</p>
				<p>IndieUI Events defines a way for web authors to register for these <em>request events</em> on a leaf node element or on a ancestor element acting as an event delegate. Authors also declaritively define which actions or behaviors a view responds to, and when it is appropriate for browsers to initiate these events.</p>
			</section>
			
			<section id="intro-goals" class="informative">
				<h3>Goals</h3>
				<p>The primary goals of the Events Module specification are declared as the following:</p>
				<ol>
					<li>Make it easier for web developers to author consistently usable interfaces that are input-agnostic and independent of a user's particular platform, hardware, locale, and preferences.</li>
					<li>Enable every type of control in these interfaces to be programmatically determinable and controllable by both mainstream and alternate forms of user input.</li>
				</ol>
				<p>The IndieUI Working Group also hopes to provide a clear path for web developers to smoothly transition from currently existing physical events to IndieUI events, during the period when implementations of IndieUI are incomplete. This will likely be achieved through polyfill implementations in common JavaScript libraries, though such implementations are not a required deliverable of the IndieUI Working Group, and documentation of this development path is not a requirement of this Events Module specification.</p>
			</section>

			<section id="intro-scope" class="informative">
				<h3>Document Scope</h3>
				<p>Decisions regarding which specific physical user interactions (keyboard combinations, gestures, speech, etc.) trigger IndieUI events are explicitly listed as out-of-scope in the Working Group charter. User interface interaction patterns should be designed and defined by each operating system, rather than defined as part of any technical specification.</p>
				<p>However, this document lists informative examples of certain keyboard and mouse events that <em>may</em> trigger each IndieUI event. They are listed here purely to aid in clarifying the reader's conceptual understanding of each event, as well as illustrating certain UI differences between platforms. These informative examples are primarily limited to keyboard and mouse events, because those physical modalities have been common in software interaction for decades, and their use is familiar to most readers.</p>
				<p>For example, it may be common for the <kbd>ESC</kbd> key to trigger a 'dismissrequest' event to close a dialog on most systems, but the specification does not require the user agent to use any particular physical event. It is an implementation detail, and left for the developers of each platform or assistive technology to determine whether <kbd>ESC</kbd> or some other interaction is the most appropriate way to trigger the 'dismissrequest' event. As long as there is a documented way for end users to initiate each event, the user agent will be considered a conforming implementation.</p>
			</section>

			<section id="intro-usage">
				<h3>Usage Examples</h3>
				
				<section id="intro-example-dismissrequest">
					<h4>Dismissing a Modal Dialog</h4>
					<p>The following example uses a 'dismissrequest' event to close or cancel out of a modal application dialog.</p>
					<pre class="example highlight">
						&lt;!-- Declare which IndieUI event(s) this element receives. --&gt;
						&lt;dialog <strong>uiactions="dismiss"</strong> id="myDialog"&gt;
						  ...
						&lt;/dialog&gt;
						
						&lt;script type="text/javascript"&gt;
						  
						  var myDialog = document.getElementById('myDialog');
						  
						  // register the event at initialization
						  // <strong>Option #1:</strong> On the receiver itself... (See next example for Option #2)
						  <strong>myDialog.addEventListener('dismissrequest', dismissHandler);</strong>
						
						  // at some point during runtime, the handler will be called
						  // (e.g. if, for example, the user presses ESC key while focus is inside the dialog)
						  function dismissHandler(e) {
						  
						    // cancel and close the dialog (don't forget to move focus before closing)
						    closeDialog(<strong>e.receiver</strong>); // Event.receiver is a readonly property like Event.target 
						    
						    // then cancel the event
						    e.stopPropagation(); // stop the event from bubbling.
						    <strong>e.preventDefault();</strong> // let the UA/AT know the event was intercepted successfully.

						  }
						&lt;/script&gt;
					</pre>
				</section>
				
				<section id="intro-example-valuechangerequest">
					<h4>Changing the Value of a Custom Slider</h4>
					<p>The following example uses a 'valuechangerequest' event to modify the value of a custom ARIA slider.</p>
					<p class="ednote">This example was cut. It needs to be rewritten once we add support for composite widgets with triggers or controllers (so the slider thumb can update the value via pointer-based events). See <a href="https://www.w3.org/WAI/IndieUI/track/actions/79">IndieUI-action-79</a>.</p>
					<pre class="example highlight" hidden>
						&lt;!-- Declare which IndieUI event(s) this element receives. --&gt;
						&lt;canvas <strong>uiactions="valuechange"</strong> id="slider" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="42"&gt;&lt;/canvas&gt;
						
						&lt;script type="text/javascript"&gt;
						  
						  // register the event at initialization
						  // <strong>Option #2:</strong> Using event delegation on any node (such as the body) that is higher in the DOM than the receiver element...
						  <strong>document.body.addEventListener('valuechangerequest', valueChangeHandler);</strong>
						
						  // at some point during runtime, the handler will be called
						  function valueChangeHandler(e) {
						    
						    // Find the event receiver element
						    var slider = e.receiver;
						    
						    // grab context info from the Event object
						    var changeType = <strong>e.changeType</strong>;
						    
						    // update the model and display
						    myApp.requestValueChangeForElement(changeType, slider);
						
						    // cancel the event
						    e.stopPropagation(); // stop the event from bubbling 
						    <strong>e.preventDefault();</strong> // let the UA/AT know the event was intercepted successfully
						
						  }
						&lt;/script&gt;
					</pre>
				</section>
				
			</section>
			
			<section id="intro-backwards-compatibility" class="informative">
				<h3>Backwards-Compatibility</h3>
				<p>One of the core principles behind <abbr title="User Interface">UI</abbr> Change Request Events is that they operate on a backwards-compatible, opt-in basis. In other words, the web application author has to first be aware of these events, then explicitly declare each event receiver and register an event listener, or user agents behave as normal and do not initiate these events.</p>
				<p>Change request events do not cause any direct manipulation or mutation of the <abbr title="Document Object Model">DOM</abbr>, and do not have any 'default action' in the context of a web view. Instead, the event conveys the user's intent to the web application, and allows the web application to perform the appropriate action on behalf of the user, including making potential changes to the DOM. If a web application is authored to understand the change request event, it can cancel the event, which informs the user agent that the event has been captured and understood. If a web application does not cancel the event, the user agent may attempt fallback behavior or communicate to the user that the input has not been recognized.</p>
			</section>
		</section>
		<!-- :::::::::::::::::::: END INTRO :::::::::::::::::::: -->
		
		<!-- :::::::::::::::::::: UI Actions :::::::::::::::::::: -->
		<section id="actions" class="normative">
			<h2><abbr title="User Interface">UI</abbr> Actions</h2>
			<p>User interface actions are declared as enumerated token attribute values on an element. Each value corresponds to a specific <a href="#RequestEvents">UI Request Event</a>, and declares the web page author's ability to receive and handle each of the request events initiated by the user agent. In order to receive each request event, authors MUST also register for the event using  <code>Element.addEventListener()</code> at this node or higher in the DOM. User agents SHOULD NOT initiate a <a href="#RequestEvents">UI Request Event</a> when the user's <a href="#def_point_of_regard">point-of-regard</a> is not inside an element with the corresponding defined action.</p>
			
			<section id="uiactions-attribute">
				<h2>The <code>uiactions</code> IDL Attribute</h2>
				<p>The <code>uiactions</code> attribute of each instance of the Element interface MUST return a DOMTokenList <a href="#def_reflected_attribute">reflecting</a> the <a href="#uiactions-content-attribute"><code>uiactions</code> content attribute</a>.</p>
				<dl title="partial interface Element" class="idl">
					<dt>readonly attribute DOMTokenList uiactions</dt>
					<dd>A DOM element attribute whose DOMTokenList value <a href="#def_reflected_attribute">reflects</a> the value of the <a href="#uiactions-content-attribute"><code>uiactions</code> content attribute</a>. <p class="ednote">This attribute is readonly b/c DOMTokenList values are modified by methods (e.g. el.uiactions.add("pan");) rather than by string assignment (e.g. NOT el.uiactions = "pan";). Need to make sure this is clear for authors.</p></dd>
				</dl>
			</section>
			
			<section id="uiactions-content-attribute">
				<h3>The <code>uiactions</code> Content Attribute</h3>
				<p>Every element may have a <code>uiactions</code> attribute specified, which is necessary to define the <a href="#def_request_event_receiver">receiver</a> of each type of request event. The attribute, if specified, must have a value that is a set of whitespace-separated tokens representing the various actions to which the web application responds on behalf of this element. The actions that an element has assigned to it consists of all the tokens returned when the value of the <code>uiactions</code> attribute is split on whitespace. (Duplicates are ignored.)</p>
				<p>User agents MUST <a href="#def_reflected_attribute">reflect</a> the <code>uiactions</code> content attribute in the <a href="#uiactions-attribute"><code>uiactions</code> IDL attribute</a>.</p>
				<div data-transform="listActions"><!-- dynamically generates event list --></div>
                <!-- <p class="ednote">We could probably combine the 'manipulation' events into a single 'manipulation' action value. I don't foresee a case where an author would want to receive some, but not all of them, and even if that case exists, the author could just not listen for those specific events.</p> -->
				<pre class="example highlight">
					&lt;!-- body element is event listener for all events, but event receiver only for 'delete' actions. --&gt;
					&lt;body <strong>uiactions="delete"</strong>&gt;
					
					  &lt;!-- Element container for custom 'mapview' is the event receiver for 'pan' and 'zoom' actions. --&gt;
					  &lt;div id="mapview" <strong>uiactions="pan zoom"</strong>&gt; ... &lt;/div&gt;
					
					  &lt;!-- This Dialog is the event receiver for 'dismiss' actions initiated on any lower-level event target. --&gt;
					  &lt;dialog <strong>uiactions="dismiss"</strong>&gt; ... &lt;/dialog&gt;
					
					&lt;/body&gt;
					
					&lt;script type="text/javascript"&gt;
					  // registered all of these on the body as an example of event delegation to help illustrate the difference between event
					  // target (document.activeElement or other point-of-regard), receiver (element with defined actions), and listener (body)
					  document.body.addEventListener(<strong>'dismissrequest'</strong>, handleDismiss);
					  document.body.addEventListener(<strong>'panrequest'</strong>, handlePan);
					  document.body.addEventListener(<strong>'deleterequest'</strong>, handleDelete);
					  document.body.addEventListener(<strong>'zoomrequest'</strong>, handleZoom);
					&lt;/script&gt;
				</pre>
				<p class="note">In the previous example, the 'deleterequest' event may be fired any time the user's point-of-regard was inside the document, presumably when the user triggered their platform's physical event to initiate a deletion, such as pressing the <kbd>DELETE</kbd> key. However, the 'dismissrequest' would only be fired when the user's point-of-regard was inside the dialog. Likewise, the 'panrequest' and 'zoomrequest' would only be fired when the user's <a href="#def_point_of_regard">point-of-regard</a> was inside the map view.</p>
			</section>

		</section>
		<!-- :::::::::::::::::::: End UI Actions :::::::::::::::::::: -->
		
		<!-- :::::::::::::::::::: UI Request Event Interfaces :::::::::::::::::::: -->
		<section id="RequestEvents" class="normative">
			<h2><abbr title="User Interface">UI</abbr> Request Events</h2>
			
			<p class="ednote">There is purposefully no request event for activating the default action. Authors are encouraged to use a standard <code>click</code> event for default actions.</p>
			<p class="ednote">Event fires on point-of-regard (<code>document.activeElement</code>, clicked element, or AT equivalent) if applicable, or otherwise <code>document.body</code>.</p>
			<p class="ednote">Event order: These events should be asynchronous, but when used in conjunction with keyboard events, we need to define where each IndieUI event fires in the chain of <code>keydown</code>, <code>keyup</code>, and <code>keypress</code>. Probably also need an identifier to associate each event with other related physical events: e.g. this <code>dismissrequest</code> event is associated with the keyboard events <code>keydown</code>, <code>keyup</code>, and <code>keypress</code> of the <kbd>ESC</kbd> key.</p>

			<!-- :::::::::::::::::::: UIRequestEvent :::::::::::::::::::: -->
			<section id="UIRequestEvent" class="normative">
				<h3>Interface UIRequestEvent</h3>
				<p class="ednote">Separate interface from UIEvent because the @uiactions attribute will 1) affect when and where these events are fired, and 2) adds the distinction of an event <a href="#def_request_event_receiver">receiver</a> element (element declaring the uiactions attribute) in addition to the "target" element where the event initiates and the "listener" element where the event is registered for and handled.</p>
				<p>The <code>receiver</code> attribute of each instance of the UIRequestEvent interface MUST return an EventTarget matching the DOMElement where the corresponding event's action is declared via the <a href="#uiactions-attribute"><code>uiactions</code> attribute</a>.</p>
				<dl title="[Constructor(DOMString typeArg, optional UIRequestEventInit dictUIRequestEventInit)] interface UIRequestEvent : UIEvent" class="idl">
					<dt>readonly attribute EventTarget receiver</dt>
					<dd>In addition to the event target, each UI Request Event has a receiver element, which is declared via the <a href="#uiactions-content-attribute"><code>uiactions</code></a> content attribute on an ancestor node of the event target. </dd>
				</dl>
				
				<section id="determining_event_receiver">
					<h2>Determining the Event Receiver</h2>
					<p>The event receiver is determined using the following steps:</p>
					<ol>
						<li>For each event name literal (e.g. <code>"dismissrequest"</code>), determine the corresponding uiactions token (e.g. <code>"dismiss"</code>).</li>
						<li>Starting with the event's target element, determine if the element's actions list contains the corresponding action for the event (e.g. <code>el.uiactions.contains("dismiss")</code>). If the current element's action list contains the corresponding uiactions token, the event target is also the event receiver.</li>
						<li>If the current element's action list does not contain the corresponding uiactions token, move up to the parent element and try again. Continue until reaching the root element. The closest ancestor to match the corresponding action token is the event receiver.</li>
						<li>If the event receiver is still undetermined upon reaching the root element, stop. There is no valid event receiver and the user agent MUST NOT initiate the event.</li>
					</ol>
				</section>

				<div class="ednote">
					<p>May also need a way to associate IndieUI events with their physical event counterparts.</p>
					<pre>[Example]
partial interface UIEvent {
  readonly attribute EventID id; // UID of current event
  readonly attribute EventList relatedEvents; // List of related events, with ID and potentially type of each event. 
  // e.g. This 'dismissrequest' event is associated with the previous 'keydown' and 'keyup' events.
}</pre>
				</div>
				
				<section id="UIRequestEventInit">
					<h4>UIRequestEventInit</h4>
					
					<dl title="dictionary UIRequestEventInit : UIEventInit" class="idl">

						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>WindowProxy? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attribute from UIRequestEventInit -->
						<dt>EventTarget receiver = null</dt><dd></dd>

					</dl>
				</section>

				<section id="UIRequestEvents">
					<h4>UIRequestEvent Types</h4>
					<p>The different types of UIRequestEvents that can occur are:</p>
					<dl>
						<dt id="undorequest">Undo Request (<code class="event">undorequest</code>)</dt>
						<dd>
							<p>Indicates the user desires to 'undo' the previous action.</p>
							<p class="ednote">May be superseded by the <a href="https://dvcs.w3.org/hg/undomanager/raw-file/tip/undomanager.html">UndoManager</a> interface.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
							<div class="ex" title="Informative Example">
								<p>Users, wanting to 'undo' a discrete action in a web application, can indicate their intent a number of ways, including pressing <kbd>Control+Z</kbd> on Windows or Linux, <kbd>Command+Z</kbd> on Mac OS X, and even by shaking some accelerometer- or gyroscope-enabled mobile devices.</p>
							</div>
						</dd>
						<dt id="redorequest">Redo Request (<code class="event">redorequest</code>)</dt>
						<dd>
							<p>Indicates the user desires to 'redo' the previously 'undone' action.</p>
							<p class="ednote">May be superseded by the <a href="https://dvcs.w3.org/hg/undomanager/raw-file/tip/undomanager.html">UndoManager</a> interface.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
							<div class="ex" title="Informative Example">
								<p>Users, wanting to 'redo' a discrete action in a web application, can indicate their intent a number of ways, including pressing <kbd>Control+Shift+Z</kbd> on Windows or Linux, <kbd>Command+Shift+Z</kbd> on Mac OS X.</p>
							</div>
						</dd>
						<dt id="expandrequest">Expand Request (<code class="event">expandrequest</code>)</dt>
						<dd>
							<p>Indicates the user desires to to reveal information in a collapsed section (e.g. a disclosure widget) or branch node in a hierarchy (e.g., a tree view).</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>
						<dt id="collapserequest">Collapse Request (<code class="event">collapserequest</code>)</dt>
						<dd>
							<p>Indicates the user desires to hide or collapse information in an expanded section (e.g. a disclosure widget) or branch node in a hierarchy (e.g., a tree view).</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>
						<dt id="dismissrequest">Dismiss Request (<code class="event">dismissrequest</code>)</dt>
						<dd>
							<p>Indicates the user desires 'dismiss' the current view (e.g. canceling a dialog, or closing a popup menu).</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
							<div class="ex" title="Informative Example">
								<p>Users, wanting to 'escape from' or 'dismiss' a web application state (for example, closing a modal dialog), can indicate their intent a number of ways, most commonly by pressing <kbd>Escape</kbd> on keyboard-controlled operating systems. Web authors who have registered for this event should process the event to determine whether to cancel the event. If the 'dismiss' action is understood in the context of the web application, web authors should perform the appropriate action (such as closing the dialog), and cancel the event using the event object's <code>preventDefault()</code> method.</p>
							</div>
						</dd>
						<dt id="deleterequest">Delete Request (<code class="event">deleterequest</code>)</dt>
						<dd>
							<p>Indicates the user wants to initiate a 'delete' action on the <a href="#def_marked_element">marked element</a> or current view.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>
					</dl>
				</section>
			</section>
			<!-- :::::::::::::::::::: END UIRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIFocusRequestEvent :::::::::::::::::::: -->
			<section id="UIFocusRequestEvent" class="normative">
				<h3>Interface UIFocusRequestEvent</h3>

				<p class="ednote">Will probably need an ARIA 1.1 or 2.0 role for palette.</p>

				<dl title="[Constructor(DOMString typeArg, optional UIFocusRequestEventInit dictUIFocusRequestEventInit)] interface UIFocusRequestEvent : UIRequestEvent" class="idl">
					<dt>readonly attribute FocusRequestFocusType focusType</dt><dd></dd>
				</dl>
				
				<section id="FocusRequestFocusType">
					<h4>Enumeration FocusRequestFocusType</h4>
					<dl title="enum FocusRequestFocusType" class="idl">
						
						<dt>none</dt><dd>Not applicable. Event is not a linear or directional focus event.</dd>
						<dt>navFirst</dt><dd>linear first</dd>
						<dt>navPrevious</dt><dd>linear previous</dd>
						<dt>navNext</dt><dd>linear next</dd>
						<dt>navLast</dt><dd>linear last</dd>
						<dt>navUp</dt><dd>directional "North"</dd>
						<dt>navUpRight</dt><dd>directional "Northeast"</dd>
						<dt>navRight</dt><dd>directional "East"</dd>
						<dt>navDownRight</dt><dd>directional "Southeast"</dd>
						<dt>navDown</dt><dd>directional "South"</dd>
						<dt>navDownLeft</dt><dd>directional "Southwest"</dd>
						<dt>navLeft</dt><dd>directional "West"</dd>
						<dt>navUpLeft</dt><dd>directional "Northwest"</dd>
					</dl>
				</section>

				<section id="UIFocusRequestEventInit">
					<h4>UIFocusRequestEventInit</h4>
					<dl title="dictionary UIFocusRequestEventInit : UIRequestEventInit" class="idl">
						
						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>WindowProxy? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attribute from UIRequestEventInit -->
						<dt>EventTarget receiver = null</dt><dd></dd>

						<!-- Attributes from UIFocusRequestEventInit -->
						<dt>FocusRequestFocusType focusType = "NONE"</dt><dd>Type of linear or directional focus requested, as defined in the FocusRequestFocusType enumeration definition. Value remains "NONE" except when used for directionalfocusrequest or linearfocusrequest.</dd>

					</dl>
				</section>
				
				<section id="UIFocusRequestEvents">
					<h4>UIFocusRequestEvent Types</h4>
					<p class="ednote">Todo: explain these can cover focus changes when the element to focus is not yet loaded in the DOM or yet focusable (for example, in list or table views where the entire dataset is not displayed), or non-linear focus shortcuts or overrides when linear focus is not possible (for example, jumping directly from a contenteditable region to the editing toolbar, when Tab and Shift+Tab mean other things).</p>
					<p>The types of UIFocusRequestEvents that can occur are:</p>
					<dl>
						
						<dt id="directionalfocusrequest">Directional Focus Request (<code class="event">directionalfocusrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a "direction focus" request to the web application. Web authors SHOULD NOT use or register for <code>directionalfocusrequest</code> events when standard browser focus and blur events are sufficient. Using these events unnecessarily could result is reduced performance or an other negative user experience.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>focusType</code> (one of directional focusType string)</li>
							</ul>
						</dd>

						<dt id="linearfocusrequest">Linear Focus Request (<code class="event">linearfocusrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a "linear focus" request to the web application. Web authors SHOULD NOT use or register for <code>linearfocusrequest</code> events when standard browser focus and blur events are sufficient. This event type is only necessary on specialized control types such as data grids where the logical next element may not be focusable or even in the DOM until requested. Using these events unnecessarily could result is reduced performance or an other negative user experience.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>focusType</code> (one of linear focusType strings)</li>
							</ul>
						</dd>

						<dt id="palettefocusrequest">Palette Focus Request (<code class="event">palettefocusrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a "palette focus" request to the web application. Web app authors receiving this event SHOULD move focus to the first palette in the web application, or cycle focus between all available palettes. Note: palettes are sometimes referred to as non-modal dialogs or inspector windows.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>

						<dt id="toolbarfocusrequest">Toolbar Focus Request (<code class="event">toolbarfocusrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a "toolbar focus" request to the web application. Web app authors receiving this event SHOULD move focus to the main toolbar in the web application, or cycle focus between all available toolbars.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>

					</dl>
				</section>
				
			</section>
			<!-- :::::::::::::::::::: END UIFocusRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIManipulationRequestEvent :::::::::::::::::::: -->
			<section id="UIManipulationRequestEvent" class="normative">
				<h3>Interface UIManipulationRequestEvent</h3>

				<dl title="[Constructor(DOMString typeArg, optional UIManipulationRequestEventInit dictUIManipulationRequestEventInit)] interface UIManipulationRequestEvent : UIRequestEvent" class="idl">
					
					<dt>readonly attribute double? originX</dt><dd></dd>
					<dt>readonly attribute double? originY</dt><dd></dd>
					<dt>readonly attribute double deltaX</dt><dd></dd>
					<dt>readonly attribute double deltaY</dt><dd></dd>
					<dt>readonly attribute double scaleFactor</dt><dd></dd>
					<dt>readonly attribute double rotation</dt><dd></dd>

				</dl>
				
				<section id="UIManipulationRequestEventInit">
					<h4>UIManipulationRequestEventInit</h4>
					<dl title="dictionary UIManipulationRequestEventInit : UIRequestEventInit" class="idl">
						
						<!-- todo: Incorporate receiver into initializer -->
						
						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>WindowProxy? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attribute from UIRequestEventInit -->
						<dt>EventTarget receiver = null</dt><dd></dd>

						<!-- Attributes from UIManipulationRequestEventInit -->
						
						<dt>double? originX = null</dt>
						<dd>The cartesian X coordinate origin point (if one exists), measured in CSS pixels from the inside(?) left edge of element border box for the <a href="#def_request_event_receiver">receiver element</a>.</dd>
						<dt>double? originY = null</dt>
						<dd>The cartesian Y coordinate origin point (if one exists), measured in CSS pixels from the inside(?) top edge of element border box for the <a href="#def_request_event_receiver">receiver element</a>.</dd>

						<dt>double deltaX = 0.0</dt>
						<dd>The cartesian X coordinate delta from the event origin, measured in CSS pixels.</dd>
						<dt>double deltaY = 0.0</dt>
						<dd>The cartesian Y coordinate delta from the event origin, measured in CSS pixels.</dd>

						<dt>double scaleFactor = 1.0</dt>
						<dd>Scale factor, used in zoom manipulations, where 1.0 is the original scale factor. For example, a value of 2.0 or 3.0 indicates the element should enlarge to 2 or 3 times its original scale, respectively. A value of 0.5 indicates the element should decrease to one-half its original scale.</dd>

						<dt>double rotation = 0.0</dt>
						<dd>Rotation value, in degrees from 0. Positive values indicate a counter-clockwise rotation. Negative values indicate a clockwise rotation.</dd>
						
					</dl>
				</section>

				<section id="UIManipulationRequestEvents">
					<h4>Discrete UIManipulationRequestEvent Types</h4>
					<p class="note">Move and Pan request events are functionally identical, but are specified individually to aid in authoring clarity when using similar concepts like 1) moving an object on a layout canvas, and 2) panning a continuous view like a map.</p>
					<p>The <em>discrete</em> types of UIManipulationRequestEvents that can occur are:</p>
					<dl>
						<dt id="moverequest">Move Request (<code class="event">moverequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a move request to the web application with accompanying x/y delta values. This is used, for example, when moving an object to a new location on a layout canvas.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
						<dt id="panrequest">Pan Request (<code class="event">panrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a pan request to the web application with accompanying x/y delta values. This is used, for example, when changing the center point while panning a map or another custom image viewer.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
						<dt id="rotationrequest">Rotation Request (<code class="event">rotationrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a rotation request to the web application with accompanying origin x/y values and a rotation value in degrees.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>rotation</code></li>
							</ul>
							<div class="note">
								<p>In the case where a User Agent lacks a clear or relevant point of origin, user agents could send null values for <code>originX</code> and <code>originY</code>, or they could send x/y coordinates representing the center point of the event.receiver element.</p>
								<p>For example, many photo manipulation applications allow users to change orientation, or rotating a photograph 90 degrees, by pressing a key combination like <kbd>Option+LeftArrow</kbd> or <kbd>Option+RightArrow</kbd>. Since this represents a keyboard only event that is unrelated to the mouse pointer location, it would be appropriate to send null values. In many cases, web applications may not require the origin x/y coordinates for rotation events even if non-null values exist.</p>
							</div>
						</dd>
						<!-- zoom changes (e.g. maps or custom layout views) -->
						<dt id="zoomrequest">Zoom Request (<code class="event">zoomrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a zoom request to the web application with accompanying origin x/y values and the zoom scale factor. This may be used, for example, with a map view or custom layout view.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>scaleFactor</code></li>
							</ul>
							<div class="note">
								<p>Web authors may use <code>originX</code> and <code>originY</code> in the way they deem most appropriate for the context of their application. In most cases, web applications receiving zoomrequest events will center the UI "zoom" on the originX/originY coordinates if they are provided. If origin coordinates are not provided, such as in the case of a keyboard-only zoom event, web authors will likely center the UI "zoom" in the middle of the receiving view.</p>
							</div>
						</dd>
					</dl>
				</section>

                <p class="ednote">There may be a need for a combined, continuous manipulation events (e.g. Pan+Zoom simultaneously) in addition to the discrete events listed above, but the following specification ideas are incomplete. For example, we're currently missing a feature to associate related events, and a description of what 'canceling' implies.</p>

				<section id="ContinuousUIManipulationRequestEvents">
					<h4>Continuous UIManipulationRequestEvent Types</h4>
					<p class="ednote">These continuous events may need an identifier per manipulation, for example, to associate a manipulationcancelrequest with the originating manipulationstartrequest that needs to be canceled.</p>
					<p>The <em>continuous</em> types of UIManipulationRequestEvents that can occur are:</p>
					<dl>
						<dt id="manipulationstartrequest">Manipulation Start Request (<code class="event">manipulationstartrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code>, <code>rotation</code>, <code>scaleFactor</code></li>
							</ul>
						</dd>
						<dt id="manipulationchangerequest">Manipulation Change Request (<code class="event">manipulationchangerequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code>, <code>rotation</code>, <code>scaleFactor</code></li>
							</ul>
						</dd>
						<dt id="manipulationendrequest">Manipulation End Request (<code class="event">manipulationendrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code>, <code>rotation</code>, <code>scaleFactor</code></li>
							</ul>
						</dd>
						<dt id="manipulationcancelrequest">Manipulation Cancel Request (<code class="event">manipulationcancelrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code>, <code>rotation</code>, <code>scaleFactor</code></li>
							</ul>
						</dd>
					</dl>
				</section>
				
			</section>
			<!-- :::::::::::::::::::: END UIManipulationRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIScrollRequestEvent :::::::::::::::::::: -->
			<section id="UIScrollRequestEvent" class="normative">
				<h3>Interface UIScrollRequestEvent</h3>
				<dl title="[Constructor(DOMString typeArg, optional UIScrollRequestEventInit dictUIScrollRequestEventInit)] interface UIScrollRequestEvent : UIRequestEvent" class="idl">
					
					<dt>readonly attribute double? deltaX</dt><dd> </dd>
					<dt>readonly attribute double? deltaY</dt><dd> </dd>
					<dt>readonly attribute ScrollRequestScrollType scrollType</dt><dd></dd>

				</dl>

				<section id="ScrollRequestScrollType">
					<h4>Enumeration ScrollRequestScrollType</h4>
					<dl title="enum ScrollRequestScrollType" class="idl">
						<dt>deltas</dt><dd>Default value for scrollType indicating that scroll amount is provided as deltaX and deltaY in CSS pixels.</dd>
						<dt>up</dt><dd>Equivalent to the default behavior of the <kbd>UP</kbd> key in most native scroll views.</dd>
						<dt>right</dt><dd>Equivalent to the default behavior of the <kbd>RIGHT</kbd> key in most native scroll views.</dd>
						<dt>down</dt><dd>Equivalent to the default behavior of the <kbd>DOWN</kbd> key in most native scroll views.</dd>
						<dt>left</dt><dd>Equivalent to the default behavior of the <kbd>LEFT</kbd> key in most native scroll views.</dd>
						<dt>pageUp</dt><dd>Equivalent to the default behavior of the <kbd>PAGEUP</kbd> key in most native scroll views.</dd>
						<dt>pageRight</dt><dd></dd>
						<dt>pageDown</dt><dd>Equivalent to the default behavior of the <kbd>PAGEDOWN</kbd> key in most native scroll views.</dd>
						<dt>pageLeft</dt><dd></dd>
						<dt>limitUp</dt><dd>Equivalent to the default behavior of the <kbd>HOME</kbd> key in most native scroll views.</dd>
						<dt>limitRight</dt><dd></dd>
						<dt>limitDown</dt><dd>Equivalent to the default behavior of the <kbd>END</kbd> key in most native scroll views.</dd>
						<dt>limitLeft</dt><dd></dd>
					</dl>
				</section>

				<section id="UIScrollRequestEventInit">
					<h4>UIScrollRequestEventInit</h4>
					<dl title="dictionary UIScrollRequestEventInit : UIRequestEventInit" class="idl">
						
						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>WindowProxy? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attribute from UIRequestEventInit -->
						<dt>EventTarget receiver = null</dt><dd></dd>

						<!-- Attributes from UIScrollRequestEventInit  -->
						<dt>double? originX = 0.0</dt>
						<dd>The cartesian X coordinate origin point (if one exists), measured in CSS pixels from the inside(?) left edge of element border box for the <a href="#def_request_event_receiver">receiver element</a>.</dd>
						<dt>double? originY = 0.0</dt>
						<dd>The cartesian Y coordinate origin point (if one exists), measured in CSS pixels from the inside(?) top edge of element border box for the <a href="#def_request_event_receiver">receiver element</a>.</dd>
						<dt>double? deltaX = 0.0</dt><dd>The cartesian X coordinate delta from the event origin, measured in CSS pixels.</dd>
						<dt>double? deltaY = 0.0</dt><dd>The cartesian Y coordinate delta from the event origin, measured in CSS pixels.</dd>

						<dt>ScrollRequestScrollType scrollType = "deltas"</dt><dd></dd>

					</dl>
				</section>

				<section id="UIScrollRequestEvents">
					<h4>UIScrollRequestEvent Types</h4>
					<p>The discrete type of UIScrollRequestEvent that can occur is:</p>
					<dl>
						<dt id="scrollrequest">Scroll Request (<code class="event">scrollrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a scroll request to the web application with accompanying x/y delta values or one of the other defined scrollType values. Authors SHOULD only use this event and uiaction with custom scroll views that cannot be acheieved with native scroll views, because the hardware-accellerated scrolling of native views will always outperform these events.</p>
							<p class="ednote">Need an example here and clarifying text to indicate UAs "must" either send a non-default scrollType, or non-default deltas, but not both.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>scrollType</code>, <code>deltaX</code>, and <code>deltaY</code></li>
							</ul>
						</dd>
					</dl>
				</section>

				<section id="ContinuousUIScrollRequestEvents">
					<h4>Continuous UIScrollRequestEvent Types</h4>
					<p class="ednote">These continuous events may need an identifier per scroll, for example, to associate a scrollcancelrequest with the originating scrollstartrequest that needs to be canceled.</p>
					<p>The <em>continuous</em> types of UIScrollRequestEvents that can occur are:</p>
					<dl>
						<dt id="scrollstartrequest">Scroll Start Request (<code class="event">scrollstartrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
						<dt id="scrollmoverequest">Scroll Move Request (<code class="event">scrollmoverequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
						<dt id="scrollendrequest">Scroll End Request (<code class="event">scrollendrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
						<dt id="scrollcancelrequest">Scroll Cancel Request (<code class="event">scrollcancelrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
					</dl>
				</section>

			</section>
			<!-- :::::::::::::::::::: END UIScrollRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIValueChangeRequestEvent :::::::::::::::::::: -->
			<section id="UIValueChangeRequestEvent" class="normative">
				<h3>Interface UIValueChangeRequestEvent</h3>
				<dl title="[Constructor(DOMString typeArg, optional UIValueChangeRequestEventInit dictUIValueChangeRequestEventInit)] interface UIValueChangeRequestEvent : UIRequestEvent" class="idl">
					<dt>readonly attribute ValueChangeRequestChangeType changeType</dt><dd></dd>
				</dl>

				<section id="ValueChangeRequestChangeType">
					<h4>Enumeration ValueChangeRequestChangeType</h4>
					<dl title="enum ValueChangeRequestChangeType" class="idl">
						
						<dt>unknown</dt><dd></dd>
						<dt>increment</dt><dd>Equivalent to the default behavior of the <kbd>UP</kbd> key on most native sliders.</dd>
						<dt>incrementSmall</dt><dd>Equivalent to the behavior of <kbd>ALT+UP</kbd> or <kbd>OPTION+UP</kbd> on some native controls, indicating a finely tuned adjustment (e.g. +0.1% as opposed to +1%).</dd>
						<dt>incrementLarge</dt><dd>Equivalent to the default behavior of <kbd>PAGEUP</kbd> or <kbd>SHIFT+UP</kbd> on many native sliders.</dd>
						<dt>incrementMaximum</dt><dd>Equivalent to the default behavior of the <kbd>END</kbd> key on most native sliders.</dd>
						<dt>decrement</dt><dd>Equivalent to the default behavior of the <kbd>DOWN</kbd> key on most native sliders.</dd>
						<dt>decrementSmall</dt><dd>Equivalent to the behavior of <kbd>ALT+DOWN</kbd> or <kbd>OPTION+DOWN</kbd> on some native controls, indicating a finely tuned adjustment (e.g. -0.1% as opposed to -1%).</dd>
						<dt>decrementLarge</dt><dd>Equivalent to the default behavior of <kbd>PAGEDOWN</kbd> or <kbd>SHIFT+DOWN</kbd> on many native sliders.</dd>
						<dt>decrementMinimum</dt><dd>Equivalent to the default behavior of the <kbd>HOME</kbd> key on most native sliders.</dd>
					</dl>
				</section>
				
				<section id="UIValueChangeRequestEventInit">
					<h4>UIValueChangeRequestEventInit</h4>
					<dl title="dictionary UIValueChangeRequestEventInit : UIRequestEventInit" class="idl">
						
						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>WindowProxy? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attribute from UIRequestEventInit -->
						<dt>EventTarget receiver = null</dt><dd></dd>

						<!-- Attributes from UIValueChangeRequestEventInit  -->
						<dt>ValueChangeRequestChangeType changeType = "UNKNOWN"</dt><dd></dd>

					</dl>
				</section>

				<section id="UIValueChangeRequestEvents">
					<h4>UIValueChangeRequestEvent Types</h4>
					<p>The single type of UIValueChangeRequestEvent that can occur is:</p>
					<dl>
						<dt id="valuechangerequest">Value Change Request (<code class="event">valuechangerequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a value change request to the web application. Used on custom range controls like sliders, carousels, etc.</p>
							<p>Web authors MUST code applications to accept <em>all</em> values of the <code>changeType</code> attribute. For example, if there is no special behavior for <code>INCREMENT_SMALL</code> or <code>INCREMENT_LARGE</code>, web applications would behave as if they had received a basic <code>INCREMENT</code> change type.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>changeType</code></li>
							</ul>
							<div class="ex" title="Informative Example">
								<p>Users, wanting to change the value of a custom range widget (e.g. sliders or carousels) in a web application, can indicate their intent a number of ways, including pressing various keys (<kbd>Up</kbd>, <kbd>Down</kbd>, <kbd>Left</kbd>, <kbd>Right</kbd>, <kbd>PageUp</kbd>, <kbd>PageDown</kbd>, <kbd>Home</kbd>, <kbd>End</kbd>) on most keyboard-controlled interfaces. User agents understanding this intent should initiate a <code>valuechangerequest</code> event. Web authors who have registered for this event, should process the event to determine whether to cancel the event. If the value change action is understood in the context of the web application, web authors should change the value of the associated widget by an amount determined via the <code>changeType</code> argument, and cancel the event using the event object's <code>preventDefault()</code> method.</p>
							</div>
						</dd>
					</dl>
				</section>
			</section>
			<!-- :::::::::::::::::::: END UIValueChangeRequestEvent :::::::::::::::::::: -->

		</section>
		<!-- :::::::::::::::::::: END UI Request Event Interfaces :::::::::::::::::::: -->

		<!-- :::::::::::::::::::: DOM Feature Detection :::::::::::::::::::: -->
		<section id="feature-detection" class="informative">
			<h2>Feature Detection</h2>
			<p>Authors wishing to conditionally assign request event handlers based on whether the user agent supports these events can use standard objection detection for each event handler or property.</p>
			<section id="feature-detection-example-dismissrequest">
				<h4>Conditionally Assigning a UI Request Event</h4>
					<p>The following example conditionally assigns a 'dismissrequest' event based on whether the user agent has support for the feature.</p>
					<pre class="example highlight">
						if (typeof document.body.ondismissrequest !== 'undefined') {
						  // okay to use 'dismissrequest'
						  document.body.addEventListener('dismissrequest', dismissHandler);
						} else {
						  // otherwise catch the ESC key or another platform-specific equivalent event
						  document.body.addEventListener('keyup', keyHandler);
						}
					</pre>
				</section>
			<p class="ednote">Note: need to double-check that the above code sample is really the best approach.</p>
		</section>
		<!-- :::::::::::::::::::: END DOM Feature Detection :::::::::::::::::::: -->

		<!--
		ReSpec: Use @data-transform to reuse a JavaScript content formatter, and @data-oninclude to transform external content before inclusion.
		<script type="text/javascript">function xmp(r, content) { return content.replace(/</g,'&lt;').replace(/>/g,'&gt;'); } </script>
		<pre data-transform='xmp'>This markup is <b>escaped</b> like an <code>xmp</code>.</pre>
		-->
		<section id="eventslist" class="appendix">
			<h2>Events List (alphabetical)</h2>
			<div data-transform="listEvents"><!-- dynamically generates event list --></div>
		</section>
		<section id="changelog" class="appendix">
			<h2>Substantive, normative changes since the <a href="http://www.w3.org/TR/2013/WD-indie-ui-events-20130730/#changelog">last public working draft</a></h2>
			<ul>
				<li>18-Aug-2013: Enum constants formerly defined in <a href="#UIScrollRequestEvent">UIScrollRequestEvent</a>, <a href="#UIValueChangeRequestEvent">UIValueChangeRequestEvent</a>, and <a href="#UIFocusRequestEvent">UIFocusRequestEvent</a> have been changed to WebIDL enumeration identifier strings. (<a href="https://www.w3.org/WAI/IndieUI/track/actions/64">ACTION-64</a>)</li>
				<li>18-Aug-2013: Event initializer dictionaries (e.g. <a href="#UIRequestEventInit">UIRequestEventInit</a>, <a href="#UIFocusRequestEventInit">UIFocusRequestEventInit</a>) were missing inheritance declarations in the IDL.</li>
				<li>22-Aug-2013: <a href="#feature-detection">Feature detection section</a> recommends direct object detection now rather than using DOMImplementation.hasFeature().</li>
				<li>5-Mar-2014: Added continuous events for <a href="#ContinuousUIManipulationRequestEvents">Manipulation Requests (zoom, pan, move, rotate)</a> as well as for <a href="#ContinuousUIScrollRequestEvents">Scroll Requests</a>.</li>
			</ul>
		</section>
		<section id="terms" class="appendix" data-include="./include/terms.html"></section>
		<section id="acknowledgements" class="appendix" data-include="./include/ack.html"></section>
		
	</body>
</html>
