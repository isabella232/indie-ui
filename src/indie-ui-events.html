<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8">
		<title>IndieUI: Events 1.0</title>
		<link href="./csi/screen.css" rel="stylesheet" type="text/css">
		
		<!-- 
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
		<script src="http://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
		<script class="remove">
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "indie-ui-events",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2012",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://dvcs.w3.org/hg/IndieUI/raw-file/tip/events/indie-ui-events.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS:             [
            "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
            "./csi/screen.css"
          ],

          // editors, add as many as you like
          // only "name" is required, also can have url, company, companyURL in comma separated list
          editors:  [
              { name: "James Craig", company: "Apple Inc.", companyURL: "http://www.apple.com/" },
              { name: "Michael Cooper", company: "W3C", companyURL: "http://www.w3.org/" },
          ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          authors:  [
            { name: "James Craig", company: "Apple Inc.", companyURL: "http://www.apple.com/" },
          ],
          
          // name of the WG
          wg:           "Independent User Interface (Indie UI) and Web Events Working Groups",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/WAI/IndieUI/",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-indie-ui-comments",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/54953/status",
      };
    </script>
		
		
	</head>
	<body>

		<section id="abstract">
			<p class="placeholder">Placeholder abstract.</p>
		</section>

		<section id="sotd">
		</section>
		
		<!-- :::::::::::::::::::: INTRO :::::::::::::::::::: -->
		<section id="intro" class="introductory informative">
			<h2>Introduction</h2>
			<p>This specification, in conjunction with the <a href="./user_context.html">User Context Module</a>, is intended address the problem of device-, <abbr title="operating system">OS</abbr>-, and localization-independent control of web content. </p>
			<p class="placeholder">placeholder for remaining intro</p>
		</section>
		
		<!-- :::::::::::::::::::: UI Request Event Interfaces :::::::::::::::::::: -->
		<section id="RequestEvents">
			<h2><abbr title="User Interface">UI</abbr> Change Request Events</h2>
			<p>The core principle behind <abbr title="User Interface">UI</abbr> Change Request Events is that they operate on a completely backwards-compatible, opt-in basis. In other words, the web application author has to be aware of these events and register event listeners, or the user agent and assistive technology behave as they normally would.</p>
			<p><strong>Change request events do not cause any direct manipulation or mutation of the DOM.</strong> Instead, the event object conveys the user's intent to the web application, and allows the web application to make the appropriate changes to the DOM, on behalf of the user agent or assistive technology. If a web application is authored to understand the change request event, it can cancel the event using <code>preventDefault()</code>, which informs the user agent or assistive technology that the event has been captured and understood. If a web application does not cancel any change request event, the user agent or assistive technology can then attempt fallback behavior or communicate to the user that the input has not been recognized.</p>
			<p class="note" title="Informative">Note: The UIRequestEvent interface does not inherit from <a href="#AccessibilityEvent">AccessibilityEvent</a> (proposed in the following section), because we believe it will ultimately be useful outside the context of assistive technology. This may prove to be a lightweight, performant alternative to mutation events. For example, <code>DOMAttrChangeRequest</code> instead of <code>DOMAttrModified</code>.</p>
			<p class="ednote">Event fires on document.activeElement (or AT equivalent) if applicable, or otherwise document.body.</p>
			<p class="ednote">These events should be asynchronous, but when used in conjunction with keyboard events, should fire after keydown, but before both keyup and keypress.</p>

			<!-- :::::::::::::::::::: UIRequestEvent :::::::::::::::::::: -->
			<section id="UIRequestEvent">
				<h3><strong>Interface <em>UIRequestEvent</em></strong></h3>

				<div class="idlwrapper">
					<pre class="idl">interface UIRequestEvent : UIEvent {
  
  <span class="comment">// UA or AT notifies web app of a change request</span>
<!-- removed from IDL 
  const unsigned short    UNDO     =  1;
  const unsigned short    REDO     =  2;
  const unsigned short    DISMISS  =  3;
  const unsigned short    DELETE   =  4;
  const unsigned short    EXPAND   =  5;
  const unsigned short    COLLAPSE =  6;

  <span class="comment">// expect more type constants will be added for other event typesâ€¦</span>
  <span class="comment">// ZOOM_IN / ZOOM_OUT ? perhaps that should just be slider widget, covered under ValueChangeRequest</span>
  
  readonly attribute unsigned short    eventType;
-->
  
  void initUIRequestEvent(
         in DOMString typeArg,
         in boolean canBubbleArg,
         in boolean cancelableArg,
         in views::AbstractView viewArg,
         in long detailArg,
         <!--in unsigned short eventTypeArg-->
       );
};</pre>
				</div>
				<h4>The different types of UIRequestEvents that can occur are:</h4>
				<dl>
					<dt><code class="event">UndoRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology sends an 'undo' request to the web application.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>eventType</code></li>
						</ul>
					</dd>
					<dt><code class="event">RedoRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology sends a 'redo' request to the web application.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>eventType</code></li>
						</ul>
					</dd>
					<dt><code class="event">DismissRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology sends a 'dismiss' request to the web application.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>eventType</code></li>
						</ul>
					</dd>
					<dt><code class="event">DeleteRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology sends a 'delete' request to the web application.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>eventType</code></li>
						</ul>
					</dd>
					<dt><code class="event">ExpandRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology conveys intent to reveal information in a collapsed section (e.g. a disclosure widget) or branch node in a hierarchy (e.g., a tree view).</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>eventType</code></li>
						</ul>
					</dd>
					<dt><code class="event">CollapseRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology conveys intent to hide or collapse information in an expanded section (e.g. a disclosure widget) or branch node in a hierarchy (e.g., a tree view).</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>eventType</code></li>
						</ul>
					</dd>
				</dl> 
				<div class="example" title="Informative">
					<h4>Examples</h4>
					<ol>
						<li>Users, wanting to 'undo' a discrete action in a web application, can indicate their intent a number of ways, including pressing <kbd>Control+Z</kbd> on Windows or Linux, <kbd>Command+Z</kbd> on Mac OS X, and even by shaking some accelerometer- or gyroscope-enabled mobile devices. User agents understanding this intent should initiate an <code>UndoRequest</code> event. Web authors who have registered for this event should process the event to determine whether to cancel the event. If the 'undo' action is understood in the context of the web application, web authors should undo the user's change, and cancel the event using the event object's <code>preventDefault()</code> method.</li>
						<li>Users, wanting to 'escape from' or 'dismiss' a web application state (for example, closing a modal dialog), can indicate their intent a number of ways, most commonly by pressing <kbd>Escape</kbd> on keyboard-controlled operating systems<!--, or by using a two-finger <a href="http://www.apple.com/voiceover/info/guide/_1133.html">scrub gesture</a> in VoiceOver on iOS or Mac OS X-->. User agents understanding this intent should initiate an <code>DismissRequest</code> event. Web authors who have registered for this event should process the event to determine whether to cancel the event. If the 'dismiss' action is understood in the context of the web application, web authors should perform the appropriate action (such as closing the dialog), and cancel the event using the event object's <code>preventDefault()</code> method.</li>
					</ol>
				</div>
			</section>
			<!-- :::::::::::::::::::: END UIRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIScrollRequestEvent :::::::::::::::::::: -->
			<section id="UIScrollRequestEvent">
				<h3><strong>Interface <em>UIScrollRequestEvent</em></strong></h3>
				<div class="idlwrapper">
					<pre class="idl">interface UIScrollRequestEvent : UIRequestEvent {
  
  <span class="comment">// for custom scroll views or widgets (e.g. carousels, lists, grids)</span>
  const unsigned short    LEFT          =  1;
  const unsigned short    UP            =  2;
  const unsigned short    RIGHT         =  3;
  const unsigned short    DOWN          =  4;
  const unsigned short    LEFT_LIMIT    =  5;
  const unsigned short    TOP_LIMIT     =  6;
  const unsigned short    RIGHT_LIMIT   =  7;
  const unsigned short    BOTTOM_LIMIT  =  8;
  <span class="comment">// Note: these constants will likely change dramatically based on discussion from the IndieUI Face-to-Face. </span>
  
  readonly attribute unsigned short   scrollType;
  
  void initUIScrollRequestEvent(
         in DOMString typeArg,
         in boolean canBubbleArg,
         in boolean cancelableArg,
         in views::AbstractView viewArg,
         in long detailArg,
         in unsigned short eventTypeArg
         in unsigned short scrollTypeArg
       );
};</pre>
				</div>
				<h4>The single type of UIScrollRequestEvent that can occur is:</h4>
				<dl>
					<dt><code class="event">ScrollRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology sends a scroll request to the web application. Scroll events need only be used on custom scroll views (lists and grids showing data subsets, carousels, etc.), as user agents and assistive technologies already manage scrolling of native scroll views.</p>
						<p class="note" title="Informative">Note: The scroll type constants are more or less equivalent to expected behavior for <kbd>PageUp</kbd>/<kbd>PageDown</kbd> and <kbd>Home</kbd>/<kbd>End</kbd> keys on native scroll views, but also allow horizontal scrolling.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>scrollType</code></li>
						</ul>
					</dd>
				</dl>
			</section>
			<!-- :::::::::::::::::::: END UIScrollRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIValueChangeRequestEvent :::::::::::::::::::: -->
			<section id="UIValueChangeRequestEvent">
				<h3><strong>Interface <em>UIValueChangeRequestEvent</em></strong></h3>
				<div class="idlwrapper">
					<pre class="idl">interface UIValueChangeRequestEvent : UIRequestEvent {
  
  <span class="comment">// value changes (e.g. ranges)</span>
  const unsigned short    INCREMENT        =  1;
  const unsigned short    INCREMENT_SMALL  =  2;
  const unsigned short    INCREMENT_LARGE  =  3;
  const unsigned short    INCREMENT_MAX    =  4;
  const unsigned short    DECREMENT        =  5;
  const unsigned short    DECREMENT_SMALL  =  6;
  const unsigned short    DECREMENT_LARGE  =  7;
  const unsigned short    DECREMENT_MIN    =  8;
  <span class="comment">// Note: these constants will likely change dramatically based on discussion from the IndieUI Face-to-Face. </span>
  
  readonly attribute unsigned short   changeType;
  
  void initUIValueChangeRequestEvent(
         in DOMString typeArg,
         in boolean canBubbleArg,
         in boolean cancelableArg,
         in views::AbstractView viewArg,
         in long detailArg,
         in unsigned short eventTypeArg,
         in unsigned short changeTypeArg
       );
};</pre>
				</div>
				<h4>The single type of UIValueChangeRequestEvent that can occur is:</h4>
				<dl>
					<dt><code class="event">ValueChangeRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology sends a value change request to the web application.</p>
						<p>Web authors <strong class="rfc2119">should</strong> code applications to accept all values of the <code>changeType</code> argument. For example, if there is no special behavior for <code>INCREMENT_SMALL</code> or <code>INCREMENT_LARGE</code>, web applications would behave as if they had received a basic <code>INCREMENT</code> change type.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>eventType</code></li>
						</ul>
					</dd>
				</dl>
				
				<div class="example" title="Informative">
					<h4>Example</h4>
					<p>Users, wanting to change the value of a custom range widget (slider, media progressbar, etc.) in a web application, can indicate their intent a number of ways, including pressing various keys (<kbd>Up</kbd>, <kbd>Down</kbd>, <kbd>Left</kbd>, <kbd>Right</kbd>, <kbd>PageUp</kbd>, <kbd>PageDown</kbd>, <kbd>Home</kbd>, <kbd>End</kbd>) on most keyboard-controlled interfaces, and through gestures on many touch-enabled interfaces. User agents understanding this intent should initiate a <code>ValueChangeRequest</code> event. Web authors who have registered for this event, should process the event to determine whether to cancel the event. If the value change action is understood in the context of the web application, web authors should change the value of the associated widget by an amount determined via the <code>changeType</code> argument, and cancel the event using the event object's <code>preventDefault()</code> method. If the event is not cancelled by the web author, user agents may pass the literal interaction event to the web application; in this case, in the form of a keypress or touch event.</p>
				</div>
					
			</section>
			<!-- :::::::::::::::::::: END UIValueChangeRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: DOMAttributeChangeRequestEvent :::::::::::::::::::: -->
			<section id="DOMAttributeChangeRequestEvent">
				<h3><strong>Interface <em>DOMAttributeChangeRequestEvent</em></strong></h3>
				<div class="idlwrapper">
					<pre class="idl">interface DOMAttributeChangeRequestEvent : UIRequestEvent {
  
  readonly attribute DOMString    attrName;
  readonly attribute DOMString    newValue;
  
  void initDOMAttributeChangeRequestEvent(
         in DOMString typeArg,
         in boolean canBubbleArg,
         in boolean cancelableArg,
         in views::AbstractView viewArg,
         in long detailArg,
         in unsigned short eventTypeArg,
         in DOMString attrNameArg,
         in DOMString newValueArg
       );
};</pre>
				</div>
				<h4>The single type of DOMAttributeChangeRequestEvent that can occur is:</h4>
				<dl>
					<dt><code class="event">DOMAttrChangeRequest</code></dt>
					<dd>
						<p>Initiated when the user agent or assistive technology sends an attribute change request to the web application. In order for web applications to understand the intent of change request events from the user agent or assistive technology, these change requests should be limited to attributes for which a change in value indicates a discrete, defined action for known types of widgets and UI elements.</p>
						<p class="note" title="Informative">Note: Currently, this limitation indicates that <code>DOMAttrChangeRequest</code> only applies to WAI-ARIA widgets, but it has the potential to be used with future iterations of HTML5 or <abbr title="Scalable Vector Graphics">SVG</abbr>.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: Yes</li>
							<li>Context Info: <code>attrName</code>, <code>newValue</code></li>
						</ul>
					</dd>
				</dl>
				<div class="example" title="Informative">
					<h4>Examples</h4>
					<ol>
						<li>If a user wanted to expand or collapse the current node of an ARIA tree, the assistive technology would initiate a <code>DOMAttrChangeRequest</code> event on the tree item element, with the <code>attrName</code> equal to <code>aria-expanded</code>, and the <code>newValue</code> equal to <code>true</code> or <code>false</code>.</li>
						<li>If a user wanted to sort an ARIA grid on a particular column, the assistive technology would initiate a <code>DOMAttrChangeRequest</code> event on the column header element, with the <code>attrName</code> equal to <code>aria-sort</code>, and the <code>newValue</code> equal to <code>ascending</code> or <code>descending</code>.</li>
					</ol>
				</div>
			</section>
			<!-- :::::::::::::::::::: END DOMAttributeChangeRequestEvent :::::::::::::::::::: -->

		</section>
		<!-- :::::::::::::::::::: END UI Request Event Interfaces :::::::::::::::::::: -->

		<!-- :::::::::::::::::::: Accessibility Event Interfaces :::::::::::::::::::: -->
		<section id="AXevents">
			<h2>Accessibility Events</h2>
			<p>The following events are only initiated by assistive technologies, as opposed to mainstream user agents.</p>
			
			<!-- :::::::::::::::::::: AccessibilityEvent :::::::::::::::::::: -->
			<section id="AccessibilityEvent">
				<h3><strong>Interface <em>AccessibilityEvent</em></strong></h3>
				<div class="idlwrapper">
					<pre class="idl">interface AccessibilityEvent : UIEvent {
  void initAccessibilityEvent(
         in DOMString typeArg,
         in boolean canBubbleArg,
         in boolean cancelableArg,
         in views::AbstractView viewArg,
         in long detailArg
       );
};</pre>
				</div>
				<h4>The different types of AccessibilityEvents that can occur are:</h4>
				<dl>
					<dt><code class="event">ATFocusIn</code></dt>
					<dd>
						<p>Initiated when the assistive technology cursor or point of regard moves to a particular DOM node.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: No</li>
							<li>Context Info: None</li>
						</ul>
					</dd>
					<dt><code class="event">ATFocusOut</code></dt>
					<dd>
						<p>Initiated when the assistive technology cursor or point of regard leaves a particular DOM node.</p>
						<ul>
							<li>Bubbles: Yes</li>
							<li>Cancelable: No</li>
							<li>Context Info: None</li>
						</ul>
					</dd>
				</dl>
			</section>
			<!-- :::::::::::::::::::: END AccessibilityEvent :::::::::::::::::::: -->
			
		</section>
		<!-- :::::::::::::::::::: END Accessibility Event Interfaces :::::::::::::::::::: -->

		<section class="placeholder appendix">
			<h2>Acknowledgements</h2>
			<p>Placeholder for footer content (acknowledgements, terms, etc.)</p>
		</section>
		
	</body>
</html>
