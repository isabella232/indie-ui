<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8">
		<title>IndieUI: Events 1.0</title>
		<link href="./css/screen.css" rel="stylesheet" type="text/css">
		<script type="text/javascript" src="./loc/en/strings.js" class="remove"></script>
		<script type="text/javascript" src="./js/utils.js" class="remove"></script>
		<script type="text/javascript" src="./js/respec-transformers.js" class="remove"></script>
		
		<!-- 
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
		<script class="remove">
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "indie-ui-events",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          subtitle   :  "Events for User Interface Independence",

          // if you wish the publication date to be other than today, set this
          //publishDate:  "2013-01-22",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2013",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "2013-01-22",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "https://dvcs.w3.org/hg/IndieUI/raw-file/default/src/indie-ui-events.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS:             [
            "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
            "./css/screen.css"
          ],

          // editors, add as many as you like
          // only "name" is required, also can have url, company, companyURL in comma separated list
          editors:  [
              { name: "James Craig", company: "Apple Inc.", companyURL: "http://www.apple.com/" },
              { name: "Michael Cooper", company: "W3C", companyURL: "http://www.w3.org/" },
          ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          //authors:  [
          //  { name: "James Craig", company: "Apple Inc.", companyURL: "http://www.apple.com/" },
          //],
          
          // name of the WG
          wg:           "Independent User Interface (Indie UI) Working Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/WAI/IndieUI/",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-indie-ui-comments",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/54953/status",
      };
    </script>
		
		
	</head>
	<body>

		<section id="abstract">
			<p>IndieUI: Events 1.0 is an abstraction between physical, device-specific user interaction events and inferred user intent such as scrolling or changing values. This provides an intermediate layer between device- and modality-specific user interaction events, and the basic user interface functionality used by web applications. IndieUI: Events focuses on granular user interface interactions such as scrolling the view, canceling an action, changing the value of a user input widget, selecting a range, placing focus on an object, etc. Implementing platforms will combine modality-specific user input, user idiosyncratic heuristics to determine the specific corresponding Indie UI event, and send that to the web application in addition to the modality-specific input such as mouse or keyboard events, should applications wish to process it.</p>
			<p>See the <a href="#intro">introduction</a> for background and usage examples.</p>
		</section>

		<section id="sotd">
		</section>
		
		<!-- :::::::::::::::::::: INTRO :::::::::::::::::::: -->
		<section id="intro" class="informative">
			<h2>Introduction</h2>
			
			<section id="intro-background">
				<h3>Background</h3>
				<p>Scripting usable interfaces can be difficult, especially when one considers that user interface design patterns differ across software platforms, hardware, and locales, and that those interactions can be further customized based on personal preference. Individuals are accustomed to the way the interface works on their own system, and their preferred interface frequently differs from that of the web application author's preferred interface.</p>
				<p>For example, web application authors, wishing to intercept a user's intent to 'undo' the last action, need to "listen" for all of the following events:</p>
				<ul>
					<li><kbd>Control+Z</kbd> on Windows and Linux.</li>
					<li><kbd>Command+Z</kbd> on Mac OS X.</li>
					<li><em>Shake</em> events on some mobile devices.</li>
				</ul>
				<p>It would be simpler to listen for a single, normalized request to 'undo' the previous action.</p>
				<p>In addition to the general user interface challenges, custom interfaces often don't take into account users who access web content via assistive technologies that use alternate forms of input such as screen readers, switch interfaces, or speech-based command and control interfaces.</p>
				<p>For example, a web page author may script a custom interface to look like a slider (e.g. one styled to look like an <abbr title="Hypertext Markup Language">HTML</abbr> 'range' input) and behave like a slider when using standard mouse input, but there is no standard way for the value of the slider to be controlled programmatically, so the control may not be usable without a mouse or other pointer-based input.</p>
			</section>
			
			<section id="intro-goals" class="informative">
				<h3>Goals</h3>
				<p>The primary goals of this specification are declared as the following:</p>
				<ol>
					<li>Make it easier for web developers to author consistently usable interfaces that are input-agnostic and independent of a user's particular platform, hardware, locale, and preferences.</li>
					<li>Enable every type of control in these interfaces to be programmatically determinable and controllable by both mainstream and alternate forms of user input, including assistive technologies.</li>
					<li>Provide a clear path for web developers to smoothly transition from currently existing physical events to IndieUI events, during the period when implementations of IndieUI are incomplete.</li>
				</ol>
			</section>

			<section id="intro-scope" class="informative">
				<h3>Document Scope</h3>
				<p>Decisions regarding which specific physical user interactions (keyboard combinations, gestures, speech, etc.) trigger IndieUI events are explicitly listed as out-of-scope in the Working Group charter. User interface is—and should be—defined and controlled by each operating system, rather than defined as part of any technical specification.</p>
				<p>However, throughout this document are listed informative examples of certain keyboard and mouse events that <em>may</em> trigger each IndieUI event. There is no requirement for a user agent to implement these examples, and they are listed here purely to aid in clarifying the reader's conceptual understanding of each event, as well as illustrating certain UI differences between platforms. These informative examples will be limited to keyboard and mouse events, because those physical modalities have been common in software interaction for decades, and their use is familiar to most readers.</p>
				<p>For example, it may be common for the <kbd>ESC</kbd> key to trigger a 'dismissrequest' event to close a dialog, but the specification does not require the user agent to use any particular physical event. It is an implementation detail, and left for the developers of each platform or assistive technology to determine whether <kbd>ESC</kbd> or some other interaction is the most appropriate way to trigger the 'dismissrequest' event. As long as there is a way to initiate each event, the user agent will be considered a conforming implementation.</p>
			</section>

			<section id="intro-usage">
				<h3>Usage Examples</h3>
				
				<section id="intro-example-dismissrequest"0>
					<h4>Dismissing a Modal Dialog</h4>
					<p>The following example uses a 'dismissrequest' event to close or cancel out of a modal application dialog.</p>
					<pre class="example">
						<span class="markup" data-transform="syntaxMarkup">
						&lt;!-- Declare which IndieUI event(s) this element receives. --&gt;
						&lt;dialog <strong>uiactions="dismiss"</strong> id="myDialog"&gt;
						  ...
						&lt;/dialog&gt;
						
						&lt;script type="text/javascript"&gt;</span><!--
						--><span class="javascript" data-transform="syntaxJavaScript">
						  
						  var myDialog = document.getElementById('myDialog');
						  
						  // register the event at initialization
						  // <strong>Option #1:</strong> On the receiver itself... (See next example for Option #2)
						  <strong>myDialog.addEventListener('dismissrequest', dismissHandler);</strong>
						
						  // at some point during runtime, the handler will be called
						  // (e.g. if, for example, the user presses ESC key while focus is inside the dialog)
						  function dismissHandler(e) {
						  
						    // cancel and close the dialog (don't forget to move focus before closing)
						    closeDialog(<strong>e.receiver</strong>); // Event.receiver is a readonly property like Event.target 
						    
						    // then cancel the event
						    e.stopPropagation(); // stop the event from bubbling.
						    <strong>e.preventDefault();</strong> // let the UA/AT know the event was intercepted successfully.

						  }</span>
						<span class="markup" data-transform="syntaxMarkup">
						&lt;/script&gt;
						</span>
					</pre>
				</section>
				
				<section id="intro-example-valuechangerequest"0>
					<h4>Changing the Value of a Custom Slider</h4>
					<p>The following example uses a 'valuechangerequest' event to modify the value of a custom ARIA slider.</p>
					<pre class="example">
						<span class="markup" data-transform="syntaxMarkup">
						&lt;!-- Declare which IndieUI event(s) this element receives. --&gt;
						&lt;canvas <strong>uiactions="valuechange"</strong> id="slider" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="42"&gt;&lt;/canvas&gt;
						
						&lt;script type="text/javascript"&gt;</span><!--
						--><span class="javascript" data-transform="syntaxJavaScript">
						  
						  // register the event at initialization
						  // <strong>Option #2:</strong> Using event delegation on any node (such as the body) that is higher in the DOM than the receiver element...
						  <strong>document.body.addEventListener('valuechangerequest', valueChangeHandler);</strong>
						
						  // at some point during runtime, the handler will be called
						  function valueChangeHandler(e) {
						    
						    // Find the event receiver element
						    var slider = e.receiver;
						    
						    // grab context info from the Event object
						    var changeType = <strong>e.request.changeType</strong>; // todo: Event.request object yet to be defined
						    
						    // update the model and display
						    myApp.requestValueChangeForElement(changeType, slider);
						
						    // cancel the event
						    e.stopPropagation(); // stop the event from bubbling 
						    <strong>e.preventDefault();</strong> // let the UA/AT know the event was intercepted successfully
						
						  }</span>
						<span class="markup" data-transform="syntaxMarkup">
						&lt;/script&gt;
						</span>
					</pre>
				</section>
				
			</section>
			
			<section id="intro-backwards-compatibility" class="informative">
				<h3>Backwards-Compatibility</h3>
				<p>One of the core principles behind <abbr title="User Interface">UI</abbr> Change Request Events is that they operate on a backwards-compatible, opt-in basis. In other words, the web application author has to first be aware of these events, then explicitly declare each event receiver and register an event listener, or user agents behave as they normally would.</p>
				<p>Change request events do not cause any direct manipulation or mutation of the <abbr title="Document Object Model">DOM</abbr>, and do not have any 'default action' in the context of a web view. Instead, the event conveys the user's intent to the web application, and allows the web application to perform the appropriate action on behalf of the user, including making potential changes to the DOM. If a web application is authored to understand the change request event, it can cancel the event, which informs the user agent that the event has been captured and understood. If a web application does not cancel the event, the user agent may attempt fallback behavior or communicate to the user that the input has not been recognized.</p>
			</section>
		</section>
		<!-- :::::::::::::::::::: END INTRO :::::::::::::::::::: -->
		
		<!-- :::::::::::::::::::: UI Actions :::::::::::::::::::: -->
		<section id="actions" class="normative">
			<h2><abbr title="User Interface">UI</abbr> Actions</h2>
			<p>User interface actions are declared as enumerated token attribute values on an element. Each value corresponds to a specific <a href="#RequestEvents">UI Request Event</a>, and declares the web page author's ability to receive and handle each of the request events initiated by the user agent. In order to receive each request event, authors MUST also register for the event using  <code>Element.addEventListener()</code> at this node or higher in the DOM. User agents SHOULD NOT initiate a <a href="#RequestEvents">UI Request Event</a> when the user's <a href="#def_point_of_regard">point-of-regard</a> is not inside an element with the corresponding defined action.</p>
			
			<section id="uiactions-attribute">
				<h2>The <code>uiactions</code> IDL Attribute</h2>
				<p>The <code>uiactions</code> attribute of each instance of the Element interface MUST return a DOMString <a href="#def_reflected_attribute">reflecting</a> the <a href="#uiactions-content-attribute"><code>uiactions</code> content attribute</a>.</p>
				<dl title="partial interface Element" class="idl">
					<dt>attribute DOMString uiactions</dt>
					<dd>A DOM element attribute whose string value <a href="#def_reflected_attribute">reflects</a> the value of the <a href="#uiactions-content-attribute"><code>uiactions</code> content attribute</a>.</dd>
				</dl>
			</section>
			
			<section id="uiactions-content-attribute">
				<h3>The <code>uiactions</code> Content Attribute</h3>
				<p>Every element may have a <code>uiactions</code> attribute specified, which is necessary to define the <a href="#def_request_event_receiver">receiver</a> of each type of request event. The attribute, if specified, must have a value that is a set of whitespace-separated tokens representing the various actions to which the web application responds on behalf of this element. The actions that an element has assigned to it consists of all the tokens returned when the value of the <code>uiactions</code> attribute is split on whitespace. (Duplicates are ignored.)</p>
				<p>User agents MUST <a href="#def_reflected_attribute">reflect</a> the <code>uiactions</code> content attribute in the <a href="#uiactions-attribute"><code>uiactions</code> IDL attribute</a>.</p>
				<div data-transform="listActions"><!-- dynamically generates event list --></div>
                <!-- <p class="ednote">We could probably combine the 'manipulation' events into a single 'manipulation' action value. I don't foresee a case where an author would want to receive some, but not all of them, and even if that case exists, the author could just not listen for those specific events.</p> -->
				<pre class="example">
					<span class="markup" data-transform="syntaxMarkup">
					&lt;!-- body element is event listener for all events, but event receiver only for 'undo' actions. --&gt;
					&lt;body <strong>uiactions="undo"</strong>&gt;
					
					  &lt;!-- Element container for custom 'mapview' is the event receiver for 'pan' and 'zoom' actions. --&gt;
					  &lt;div id="mapview" <strong>uiactions="pan zoom"</strong>&gt; ... &lt;/div&gt;
					
					  &lt;!-- This Dialog is the event receiver for 'dismiss' actions initiated on any lower-level event target. --&gt;
					  &lt;dialog <strong>uiactions="dismiss"</strong>&gt; ... &lt;/dialog&gt;
					
					&lt;/body&gt;
					
					&lt;script type="text/javascript"&gt;</span>
					  <span class="javascript" data-transform="syntaxJavaScript">
					  // registered all of these on the body as an example of event delegation to help illustrate the difference between event
					  // target (document.activeElement or other point-of-regard), receiver (element with defined actions), and listener (body)
					  document.body.addEventListener(<strong>'dismissrequest'</strong>, handleDismiss);
					  document.body.addEventListener(<strong>'panrequest'</strong>, handlePan);
					  document.body.addEventListener(<strong>'undorequest'</strong>, handleUndo);
					  document.body.addEventListener(<strong>'zoomrequest'</strong>, handleZoom);
					</span><span class="markup" data-transform="syntaxMarkup">
					&lt;/script&gt;
					</span>
				</pre>
				<p class="note">In the previous example, the 'undorequest' event may be fired any time the user's point-of-regard was inside the document<!-- , presumably when the user triggered their platform's physical event to undo an action, such as <kbd>Control+Z</kbd> or <kbd>Command+Z</kbd> -->. However, the 'dismissrequest' would only be fired when the user's point-of-regard was inside the dialog. Likewise, the 'panrequest' and 'zoomrequest' would only be fired when the user's <a href="#def_point_of_regard">point-of-regard</a> was inside the map view.</p>
			</section>

		</section>
		<!-- :::::::::::::::::::: End UI Actions :::::::::::::::::::: -->
		
		<!-- :::::::::::::::::::: UI Request Event Interfaces :::::::::::::::::::: -->
		<section id="RequestEvents" class="normative">
			<h2><abbr title="User Interface">UI</abbr> Request Events</h2>
			
			<p class="ednote">There is purposefully no request event for activating the default action. Authors are encouraged to use a standard <code>click</code> event for default actions.</p>
			<p class="ednote">Event fires on point-of-regard (<code>document.activeElement</code>, clicked element, or AT equivalent) if applicable, or otherwise <code>document.body</code>.</p>
			<p class="ednote">Event order: These events should be asynchronous, but when used in conjunction with keyboard events, we need to define where each IndieUI event fires in the chain of <code>keydown</code>, <code>keyup</code>, and <code>keypress</code>. Probably also need an identifier to associate each event with other related physical events: e.g. this <code>dismissrequest</code> event is associated with the keyboard events <code>keydown</code>, <code>keyup</code>, and <code>keypress</code> of the <kbd>ESC</kbd> key.</p>

			<!-- :::::::::::::::::::: UIRequestEvent :::::::::::::::::::: -->
			<section id="UIRequestEvent" class="normative">
				<h3>Interface UIRequestEvent</h3>
				<p class="ednote">Separate interface from UIEvent because the @uiactions attribute will 1) affect when and where these events are fired, and 2) adds the distinction of an event <a href="#def_request_event_receiver">receiver</a> element (element declaring the uiactions attribute) in addition to the "target" element where the event initiates and the "listener" element where the event is registered for and handled.</p>
				<dl title="[Constructor(DOMString typeArg, optional UIRequestEventInit dictUIRequestEventInit)] interface UIRequestEvent : UIEvent" class="idl">
					<dt>readonly attribute EventTarget receiver</dt>
					<dd>In addition to the target and currentTarget, each UI Request Event has a receiver element, which is declared via the <a href="#uiactions-content-attribute"><code>uiactions</code></a> content attribute on an ancestor node of the event target. <p class="ednote">Note: This may need to be defined as a partial interface on AbstractView, rather than in this interface.</p></dd>
				</dl>
				
				<div class="ednote">
					<p>May also need a way to associate IndieUI events with their physical event counterparts.</p>
					<pre>[Example]
partial interface UIEvent {
  readonly attribute EventID id; // UID of current event
  readonly attribute EventList relatedEvents; // List of related events, with ID and potentially type of each event. 
  // e.g. This 'dismissrequest' event is associated with the previous 'keydown' and 'keyup' events.
}</pre>
				</div>
				
				<section id="UIRequestEventInit">
					<h4>UIRequestEventInit</h4>
					<p class="ednote">This might not need its own UIRequestEventInit, it could potentially use UIEventInit, depending on whether the EventTarget <a href="#def_request_event_receiver">receiver</a> is implemented here or on AbstractView.</p>
					
					<dl title="dictionary UIRequestEventInit" class="idl">

						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>AbstractView? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attributes from UIRequestEventInit -->
						<dt>EventTarget? relatedTarget = null;</dt><dd></dd>
						<dt>EventReceiver? relatedReceiver = null;</dt><dd></dd>

					</dl>
				</section>

				<section id="UIRequestEvents">
					<h4>UIRequestEvent Types</h4>
					<p>The different types of UIRequestEvents that can occur are:</p>
					<dl>
						<dt id="undorequest">Undo Request (<code class="event">undorequest</code>)</dt>
						<dd>
							<p>Indicates the user desires to 'undo' the previous action.</p>
							<p class="ednote">May be superseded by the <a href="https://dvcs.w3.org/hg/undomanager/raw-file/tip/undomanager.html">UndoManager</a> interface.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
							<div class="example" title="Informative Example">
								<p>Users, wanting to 'undo' a discrete action in a web application, can indicate their intent a number of ways, including pressing <kbd>Control+Z</kbd> on Windows or Linux, <kbd>Command+Z</kbd> on Mac OS X, and even by shaking some accelerometer- or gyroscope-enabled mobile devices.</p>
							</div>
						</dd>
						<dt id="redorequest">Redo Request (<code class="event">redorequest</code>)</dt>
						<dd>
							<p>Indicates the user desires to 'redo' the previously 'undone' action.</p>
							<p class="ednote">May be superseded by the <a href="https://dvcs.w3.org/hg/undomanager/raw-file/tip/undomanager.html">UndoManager</a> interface.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
							<div class="example" title="Informative Example">
								<p>Users, wanting to 'redo' a discrete action in a web application, can indicate their intent a number of ways, including pressing <kbd>Control+Shift+Z</kbd> on Windows or Linux, <kbd>Command+Shift+Z</kbd> on Mac OS X.</p>
							</div>
						</dd>
						<dt id="expandrequest">Expand Request (<code class="event">expandrequest</code>)</dt>
						<dd>
							<p>Indicates the user desires to to reveal information in a collapsed section (e.g. a disclosure widget) or branch node in a hierarchy (e.g., a tree view).</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>
						<dt id="collapserequest">Collapse Request (<code class="event">collapserequest</code>)</dt>
						<dd>
							<p>Indicates the user desires to hide or collapse information in an expanded section (e.g. a disclosure widget) or branch node in a hierarchy (e.g., a tree view).</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>
						<dt id="dismissrequest">Dismiss Request (<code class="event">dismissrequest</code>)</dt>
						<dd>
							<p>Indicates the user desires 'dismiss' the current view (e.g. canceling a dialog, or closing a popup menu).</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
							<div class="example" title="Informative Example">
								<p>Users, wanting to 'escape from' or 'dismiss' a web application state (for example, closing a modal dialog), can indicate their intent a number of ways, most commonly by pressing <kbd>Escape</kbd> on keyboard-controlled operating systems. Web authors who have registered for this event should process the event to determine whether to cancel the event. If the 'dismiss' action is understood in the context of the web application, web authors should perform the appropriate action (such as closing the dialog), and cancel the event using the event object's <code>preventDefault()</code> method.</p>
							</div>
						</dd>
						<dt id="deleterequest">Delete Request (<code class="event">deleterequest</code>)</dt>
						<dd>
							<p>Indicates the user wants to initiate a 'delete' action on the <a href="#def_marked_element">marked element</a> or current view.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>
					</dl>
				</section>
			</section>
			<!-- :::::::::::::::::::: END UIRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIFocusRequestEvent :::::::::::::::::::: -->
			<section id="UIFocusRequestEvent" class="normative">
				<h3>Interface UIFocusRequestEvent</h3>

				<p class="ednote">Will probably need an ARIA 1.1 or 2.0 role for palette.</p>
				<p class="ednote">TBD: These NAV_* constants may be better defined as dictionaries. See below.</p>

				<dl title="[Constructor(DOMString typeArg, optional UIFocusRequestEventInit dictUIFocusRequestEventInit)] interface UIFocusRequestEvent : UIRequestEvent" class="idl">

					<dt>const unsigned short NAV_FIRST = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_PREV  = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_NEXT  = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_LAST  = TBD</dt><dd></dd>

					<!-- clockwise from top -->
					<dt>const unsigned short NAV_UP         = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_UP_LEFT    = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_LEFT       = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_DOWN_LEFT  = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_DOWN       = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_DOWN_RIGHT = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_RIGHT      = TBD</dt><dd></dd>
					<dt>const unsigned short NAV_UP_RIGHT   = TBD</dt><dd></dd>
					
				</dl>
				

				<section id="UIFocusRequestEventInit">
					<h4>UIFocusRequestEventInit</h4>
					<dl title="dictionary UIFocusRequestEventInit" class="idl">
						
						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>AbstractView? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attributes from UIRequestEventInit -->
						<dt>EventTarget? relatedTarget = null;</dt><dd></dd>
						<dt>EventReceiver? relatedReceiver = null;</dt><dd></dd>

						<!-- Attributes from UIFocusRequestEventInit -->
						<dt>unsigned short? focusType = null</dt><dd>Type of linear or directional focus requested, as defined in the LinearFocusType and DirectionalFocusType interface constants.</dd>

					</dl>
				</section>

				<section id="FocusTypeValues">
					<h5>FocusType Values</h5>
					<p class="ednote">TBD: These NAV_* constants could also be defined as constants. See above.</p>
						
					<dl title="dictionary LinearFocusType" class="idl">
						<dt>const unsigned short NAV_FIRST = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_PREV  = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_NEXT  = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_LAST  = TBD</dt><dd></dd>
					</dl>

					<dl title="dictionary DirectionalFocusType" class="idl">
						<!-- clockwise from top -->
						<dt>const unsigned short NAV_UP         = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_UP_LEFT    = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_LEFT       = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_DOWN_LEFT  = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_DOWN       = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_DOWN_RIGHT = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_RIGHT      = TBD</dt><dd></dd>
						<dt>const unsigned short NAV_UP_RIGHT   = TBD</dt><dd></dd>
					</dl>

				</section>
				
				<section id="UIFocusRequestEvents">
					<h4>UIFocusRequestEvent Types</h4>
					<p class="ednote">Todo: explain these can cover focus changes when the element to focus is not yet loaded in the DOM or yet focusable (for example, in list or table views where the entire dataset is not displayed), or non-linear focus shortcuts or overrides when linear focus is not possible (for example, jumping directly from a contenteditable region to the editing toolbar, when Tab and Shift+Tab mean other things).</p>
					<p>The types of UIFocusRequestEvents that can occur are:</p>
					<dl>
						
						<dt id="directionalfocusrequest">Directional Focus Request (<code class="event">directionalfocusrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a "direction focus" request to the web application. Web authors SHOULD NOT use or register for <code>directionalfocusrequest</code> events when standard browser focus and blur events are sufficient. Using these events unnecessarily could result is reduced performance or an other negative user experience.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>focusType</code> (one of directional focus constants)</li>
							</ul>
						</dd>

						<dt id="linearfocusrequest">Linear Focus Request (<code class="event">linearfocusrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a "linear focus" request to the web application. Web authors SHOULD NOT use or register for <code>linearfocusrequest</code> events when standard browser focus and blur events are sufficient. This event type is only necessary on specialized control types such as data grids where the logical next element may not be focusable or even in the DOM until requested. Using these events unnecessarily could result is reduced performance or an other negative user experience.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>focusType</code> (one of linear focus constants)</li>
							</ul>
						</dd>

						<dt id="palettefocusrequest">Palette Focus Request (<code class="event">palettefocusrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a "palette focus" request to the web application. Web app authors receiving this event SHOULD move focus to the first palette in the web application, or cycle focus between all available palettes. Note: palettes are sometimes referred to as non-modal dialogs or inspector windows.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>

						<dt id="toolbarfocusrequest">Toolbar Focus Request (<code class="event">toolbarfocusrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a "toolbar focus" request to the web application. Web app authors receiving this event SHOULD move focus to the main toolbar in the web application, or cycle focus between all available toolbars.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
							</ul>
						</dd>

					</dl>
				</section>
				
			</section>
			<!-- :::::::::::::::::::: END UIFocusRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIManipulationRequestEvent :::::::::::::::::::: -->
			<section id="UIManipulationRequestEvent" class="normative">
				<h3>Interface UIManipulationRequestEvent</h3>

				<dl title="[Constructor(DOMString typeArg, optional UIManipulationRequestEventInit dictUIManipulationRequestEventInit)] interface UIManipulationRequestEvent : UIRequestEvent" class="idl">
				</dl>
				
				<section id="UIManipulationRequestEventInit">
					<h4>UIManipulationRequestEventInit</h4>
					<dl title="dictionary UIManipulationRequestEventInit" class="idl">
						
						<!-- todo: Incorporate receiver into initializer -->
						
						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>AbstractView? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attributes from UIRequestEventInit -->
						<dt>EventTarget? relatedTarget = null;</dt><dd></dd>
						<dt>EventReceiver? relatedReceiver = null;</dt><dd></dd>

						<!-- Attributes from UIManipulationRequestEventInit -->
						
						<dt>optional double originX? = null</dt>
						<dd>The cartesian X coordinate origin point (if one exists), measured in CSS pixels from the left edge of element box for the <a href="#def_request_event_receiver">receiver element</a>.</dd>
						<dt>optional double originY? = null</dt>
						<dd>The cartesian Y coordinate origin point (if one exists), measured in CSS pixels from the top edge of element box for the <a href="#def_request_event_receiver">receiver element</a>.</dd>

						<dt>optional double deltaX = 0.0</dt>
						<dd>The cartesian X coordinate delta, in CSS pixels.</dd>
						<dt>optional double deltaY = 0.0</dt>
						<dd>The cartesian Y coordinate delta, in CSS pixels.</dd>

						<dt>optional double scaleFactor = 1.0</dt>
						<dd>Scale factor, used in zoom manipulations, where 1.0 is the original scale factor. For example, a value of 2.0 or 3.0 indicates the element should enlarge to 2 or 3 times its original scale, respectively. A value of 0.5 indicates the element should decrease to one-half its original scale.</dd>

						<dt>optional double rotation = 0.0</dt>
						<dd>Rotation value, in degrees from 0. Positive values indicate a counter-clockwise rotation. Negative values indicate a clockwise rotation.</dd>
						
					</dl>
				</section>

				<section id="UIManipulationRequestEvents">
					<h4><!-- Discrete  -->UIManipulationRequestEvent Types</h4>
					<p class="note">Move, Pan, and Scroll request events are functionally identical, but are specified individually to aid in authoring clarity when using similar concepts like 1) moving an object on a layout canvas, 2) panning a continuous view like a map, and 3) scrolling a scroll view.</p>
					<p>The <!-- <em>discrete</em>  -->types of UIManipulationRequestEvents that can occur are:</p>
					<dl>
						<dt id="moverequest">Move Request (<code class="event">moverequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a move request to the web application with accompanying x/y delta values. This is used, for example, when moving an object to a new location on a layout canvas.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
						<dt id="panrequest">Pan Request (<code class="event">panrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a pan request to the web application with accompanying x/y delta values. This is used, for example, when changing the center point while panning a map or another custom image viewer.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
						<dt id="rotationrequest">Rotation Request (<code class="event">rotationrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a rotation request to the web application with accompanying origin x/y values and a rotation value in degrees.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>rotation</code></li>
							</ul>
							<div class="note">
								<p>In the case where a User Agent lacks a clear or relevant point of origin, user agents could send null values for <code>originX</code> and <code>originY</code>, or they could send x/y coordinates representing the center point of the event.receiver element.</p>
								<p>For example, many photo manipulation applications allow users to change orientation, or rotating a photograph 90 degrees, by pressing a key combination like <kbd>Option+LeftArrow</kbd> or <kbd>Option+RightArrow</kbd>. Since this represents a keyboard only event that is unrelated to the mouse pointer location, it would be appropriate to send null values. In many cases, web applications may not require the origin x/y coordinates for rotation events even if non-null values exist.</p>
							</div>
						</dd>
						<dt id="scrollrequest">Scroll Request (<code class="event">scrollrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a scroll request to the web application with accompanying x/y delta values.</p>
							<p class="ednote">Need to specify algorithm for determining x/y deltas for events like pagedown/pageup. Should probably be max of <a href="#def_request_event_receiver">receiver</a> element width/height, or user agent viewport width/height (delta if overlapped inexactly), with potential for a smaller assistive technology viewport (e.g. if screen zoom does not show entirety of previous calculation's width/height).</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>deltaX</code>, <code>deltaY</code></li>
							</ul>
						</dd>
						<!-- zoom changes (e.g. maps or custom layout views) -->
						<dt id="zoomrequest">Zoom Request (<code class="event">zoomrequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a zoom request to the web application with accompanying origin x/y values and the zoom scale factor.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>scaleFactor</code></li>
							</ul>
							<div class="note">
								<p>Web authors may use <code>originX</code> and <code>originY</code> in the way they deem most appropriate for the context of their application. In most cases, web applications receiving zoomrequest events will center the UI "zoom" on the originX/originY coordinates if they are provided. If origin coordinates are not provided, such as in the case of a keyboard-only zoom event, web authors will likely center the UI "zoom" in the middle of the receiving view.</p>
							</div>
						</dd>
					</dl>
				</section>

                <p class="ednote">There may be a need for a combined, continuous manipulation events (e.g. Pan+Zoom simultaneously) in addition to the discrete events listed above, but specification ideas are incomplete. Currently an author could achieve the same result by listening for the series of discrete Zoom and Pan events.</p>

<!-- Commenting the continuous events to avoid confusion, as they are not ready (for example, missing feature to associate related events, and a description of what 'canceling' implies). It's possible they may not even be necessary, given that one can get the same behavior from a series of discrete events. -->
<!--
				<section id="ContinuousUIManipulationRequestEvents">
					<h4>Continuous UIManipulationRequestEvent Types</h4>
					<p class="ednote">These continuous events may need an identifier per manipulation, for example, to associate a manipulationcancelrequest with the originating manipulationstartrequest that needs to be canceled.</p>
					<p>The <em>continuous</em> types of UIManipulationRequestEvents that can occur are:</p>
					<dl>
						<dt id="manipulationstartrequest">Manipulation Start Request (<code class="event">manipulationstartrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code>, <code>rotation</code>, <code>scaleFactor</code></li>
							</ul>
						</dd>
						<dt id="manipulationchangerequest">Manipulation Change Request (<code class="event">manipulationchangerequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code>, <code>rotation</code>, <code>scaleFactor</code></li>
							</ul>
						</dd>
						<dt id="manipulationendrequest">Manipulation End Request (<code class="event">manipulationendrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code>, <code>rotation</code>, <code>scaleFactor</code></li>
							</ul>
						</dd>
						<dt id="manipulationcancelrequest">Manipulation Cancel Request (<code class="event">manipulationcancelrequest</code>)</dt>
						<dd>
							<p class="todo">TBD</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>originX</code>, <code>originY</code>, <code>deltaX</code>, <code>deltaY</code>, <code>rotation</code>, <code>scaleFactor</code></li>
							</ul>
						</dd>
					</dl>
				</section>
-->				
				
			</section>
			<!-- :::::::::::::::::::: END UIManipulationRequestEvent :::::::::::::::::::: -->

			<!-- :::::::::::::::::::: UIValueChangeRequestEvent :::::::::::::::::::: -->
			<section id="UIValueChangeRequestEvent" class="normative">
				<h3>Interface UIValueChangeRequestEvent</h3>
				<dl title="[Constructor(DOMString typeArg, optional UIValueChangeRequestEventInit dictUIValueChangeRequestEventInit)] interface UIValueChangeRequestEvent : UIRequestEvent" class="idl">
					<dt>const unsigned short INCREMENT       = 1</dt><dd></dd>
					<dt>const unsigned short INCREMENT_SMALL = 2</dt><dd></dd>
					<dt>const unsigned short INCREMENT_LARGE = 3</dt><dd></dd>
					<dt>const unsigned short INCREMENT_MAX   = 4</dt><dd></dd>
					<dt>const unsigned short DECREMENT       = 5</dt><dd></dd>
					<dt>const unsigned short DECREMENT_SMALL = 6</dt><dd></dd>
					<dt>const unsigned short DECREMENT_LARGE = 7</dt><dd></dd>
					<dt>const unsigned short DECREMENT_MIN   = 8</dt><dd></dd>
				</dl>
				
				<section id="UIValueChangeRequestEventInit">
					<h4>UIValueChangeRequestEventInit</h4>
					<dl title="dictionary UIValueChangeRequestEventInit" class="idl">
						
						<!-- Attributes from EventInit -->
						<dt>boolean bubbles = true</dt><dd></dd>
						<dt>boolean cancelable = true</dt><dd></dd>

						<!-- Attributes from UIEventInit -->
						<dt>AbstractView? view = null</dt><dd></dd>
						<dt>long detail = 0</dt><dd></dd>

						<!-- Attributes from UIRequestEventInit -->
						<dt>EventTarget? relatedTarget = null;</dt><dd></dd>
						<dt>EventReceiver? relatedReceiver = null;</dt><dd></dd>

						<!-- Attributes from UIValueChangeRequestEventInit  -->
						<dt>unsigned short? changeType = null</dt><dd>Type of change requested, as defined in the interface constants.</dd>

					</dl>
				</section>

				<section id="UIValueChangeRequestEvents">
					<h4>UIValueChangeRequestEvent Types</h4>
					<p>The single type of UIValueChangeRequestEvent that can occur is:</p>
					<dl>
						<dt id="valuechangerequest">Value Change Request (<code class="event">valuechangerequest</code>)</dt>
						<dd>
							<p>Initiated when the user agent sends a value change request to the web application. Used on custom range controls like sliders, carousels, etc.</p>
							<p>Web authors MUST code applications to accept <em>all</em> values of the <code>changeType</code> attribute. For example, if there is no special behavior for <code>INCREMENT_SMALL</code> or <code>INCREMENT_LARGE</code>, web applications would behave as if they had received a basic <code>INCREMENT</code> change type.</p>
							<ul>
								<li>Bubbles: Yes</li>
								<li>Cancelable: Yes</li>
								<li>Context Info: <code>changeType</code></li>
							</ul>
							<div class="example" title="Informative Example">
								<p>Users, wanting to change the value of a custom range widget (e.g. sliders or carousels) in a web application, can indicate their intent a number of ways, including pressing various keys (<kbd>Up</kbd>, <kbd>Down</kbd>, <kbd>Left</kbd>, <kbd>Right</kbd>, <kbd>PageUp</kbd>, <kbd>PageDown</kbd>, <kbd>Home</kbd>, <kbd>End</kbd>) on most keyboard-controlled interfaces. User agents understanding this intent should initiate a <code>valuechangerequest</code> event. Web authors who have registered for this event, should process the event to determine whether to cancel the event. If the value change action is understood in the context of the web application, web authors should change the value of the associated widget by an amount determined via the <code>changeType</code> argument, and cancel the event using the event object's <code>preventDefault()</code> method.</p>
							</div>
						</dd>
					</dl>
				</section>
			</section>
			<!-- :::::::::::::::::::: END UIValueChangeRequestEvent :::::::::::::::::::: -->

		</section>
		<!-- :::::::::::::::::::: END UI Request Event Interfaces :::::::::::::::::::: -->

		<!--
		ReSpec: Use @data-transform to reuse a JavaScript content formatter, and @data-oninclude to transform external content before inclusion.
		<script type="text/javascript">function xmp(r, content) { return content.replace(/</g,'&lt;').replace(/>/g,'&gt;'); } </script>
		<pre data-transform='xmp'>This markup is <b>escaped</b> like an <code>xmp</code>.</pre>
		-->
		<section id="eventslist" class="appendix">
			<h2>Events List (alphabetical)</h2>
			<div data-transform="listEvents"><!-- dynamically generates event list --></div>
		</section>
		<section id="changelist" class="appendix">
			<h2>Normative changes since the last public working draft</h2>
			<ul>
				<li>30 Apr 2013: The reflected attribute uiActions/@ui-actions is now uiactions/@uiactions.</li>
				<li>01 May 2013: Added UIFocusRequestEvent section.</li>
			</ul>
		</section>
		<section id="terms" class="appendix" data-include="./include/terms.html"></section>
		<section id="acknowledgements" class="appendix" data-include="./include/ack.html"></section>
		
	</body>
</html>
